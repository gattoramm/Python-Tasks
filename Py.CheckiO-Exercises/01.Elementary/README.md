# Elementary

> Before a big journey begins, let's warmup a bit. Some very simple missions will help you remember how to use code as well as how CheckiO works. Don’t forget to check out the solutions of other users. Those are the best!

## Say Hi
> В этой миссии вы должны написать функцию, которая представит человека по переданным параметрам.

> **Входные данные**: Два аргумента строка(str) и положительное число(int)

> **Выходные данные**: Строка(str).

## Easy Unpack
> Ваше задание здесь создать функцию, которая получает массив(tuple) и возвращает набор с 3 элементами - первым, третьим, вторым с конца.

> **Входные данные**: Набор длинной не менее 3 элементов.

> **Выходные данные**: Набор элементов.

## Index Power
> Дан массив с положительными числами и число N. Вы должны найти N-ую степень элемента в массиве с индексом N. Если N за границами массива, тогда вернуть -1. Не забывайте, что первый элемент имеет индекс 0.

> Давайте посмотрим на несколько примеров:
>	* массив = [1, 2, 3, 4] и N = 2, тогда результат 32 == 9;
>	* массив = [1, 2, 3] и N = 3, но N за границами массива, так что результат -1.

> **Входные значения**: Два агумента. Массив как список целых и число как целое.

> **Выходные значения**: Целое число.

## Secret Message
> Когда-нибудь пробовали отправить секретное сообщение кому-то не пользуясь услугами почты? Вы можете использовать газету, чтобы рассказать кому-то свой секрет. Даже если кто-то найдет ваше сообщение, легко отмахнуться и сказать что это паранойя и теория заговора. Один из самых простых способов спрятать ваше секретное сообщение это использовать заглавные буквы. Давайте найдем несколько таких секретных сообщений.

> Дан кусок текста. Соберите все заглавные буквы в одно слово в том порядке как они встречаются в куске текста.

> Например: текст = `"How are you? Eh, ok. Low or Lower? Ohhh."`, если мы соберем все заглавные буквы, то получим сообщение `"HELLO"`.

> **Входные данные**: Текст как строка (юникод).

> **Выходные данные**: Секретное сообщение как строка или пустая строка.

## Fizz Buzz
> "Fizz buzz" это игра со словами, с помощью которой мы будем учить наших роботов делению. Давайте обучим компьютер.  
Вы должны написать функцию, которая принимает положительное целое число и возвращает:
> * **"Fizz Buzz"**, если число делится на 3 и 5;  
> * **"Fizz"**, если число делится на 3;  
> * **"Buzz"**, если число делится на 5;  
> * Число, как строку для остальных случаев.

> **Входные данные**: Число, как целочисленное (int).

> **Выходные данные**: Ответ, как строка (str).

## Even the Last
> Дан массив целых чисел. Нужно найти сумму элементов с четными индексами (0-й, 2-й, 4-й итд), затем перемножить эту сумму и последний элемент исходного массива. Не забудьте, что первый элемент массива имеет индекс 0.

> Для пустого массива результат всегда 0 (ноль).

> **Входные данные**: Список (list) целых чисел (int).

> **Выходные данные**: Число как целочисленное (int).

## Best Stock
> Вам даны текущие цены на акции. Вам необходимо выяснить за какие акции дают большую цену.

> **Входные данные**: Словарь (dict), в котором ключи - это рыночный код, а значение - это цена за акцию(float)
> **Выходные данные**: Строка, рыночный код

## Correct Sentence
> На вход Вашей функции будет передано одно предложение. Необходимо вернуть его исправленную копию так, чтобы оно всегда начиналось с большой буквы и заканчивалось точкой.  
Обратите внимание на то, что не все исправления необходимы. Если предложение уже заканчивается на точку, то добавлять еще одну не нужно, это будет ошибкой.

> **Входные аргументы**: Строка (A string).
 
> **Выходные аргументы**: Строка (A string).

## Right to Left
> Один робот был занят простой задачей: объединить последовательность строк в одно выражение для создания инструкции по обходу корабля. Но робот был левша и зачастую шутил и запутывал своих друзей правшей.

> Дана последовательность строк. Вы должны объединить эти строки в блок текста, разделив изначальные строки запятыми. В качестве шутки над праворукими роботами, вы должны заменить все вхождения слова "right" на слова "left", даже если это часть другого слова. Все строки даны в нижнем регистре.

> **Входные данные**: Последовательность строк, как кортеж строк (юникод).

> **Выходные данные**: Текст, как строка.

## Second Index
> Даны 2 строки. Необходимо найти индекс второго вхождения второй строки в первую.

> Разберем самый первый пример, когда необходимо найти второе вхождение `"s"` в слове `"sims"`. Если бы нам надо было найти ее первое вхождение, то тут все просто: с помощью функции index или find мы можем узнать, что `"s"` – это самый первый символ в слове `"sims"`, а значит индекс первого вхождения равен `0`. Но нам необходимо найти вторую `"s"`, а она `4`-ая по счету. Значит индекс второго вхождения (и ответ на вопрос) равен `3`.

> **Входные аргументы**: Две строки (String).  
> **Выходные аргументы**: Int or None

## Absolute Sorting
> Массив (tuple) содержит различные числа. Вам необходимо отсортировать их, но отсортировать на основе абсолютных значений в возрастающем порядке. Для примера, последовательность (-20, -5, 10, 15) будет отсортирована следующим образом (-5, 10, 15, -20). Ваша функция должна возвращать список (list) или кортеж (tuple).

> **Входные данные**: Массив чисел как кортеж (tuple).

> **Выходные данные**: Список (list) или кортеж (tuple) (но не генератор) отсортированный по абсолютным значениям чисел.

## The Most Numbers
> Дан массив чисел (float или/и int). Вам нужно найти разницу между самым большим (максимум) и самым малым (минимум) элементом. Ваша функция должна уметь работать с неопределенным количеством аргументов. Если аргументов нет, то функция возвращает 0 (ноль).

> Числа с плавающей точкой представлены в компьютерах как двоичная дробь. Результат проверяется с точностью до третьего знака, как ±0.001
Прочитайте о том как работать с переменым числом аргументов.

> **Входные параметры**: Переменное число аргументов как числа (int, float).

> **Выходные параметры**: Разница между максимумом и минимумом как число (int, float).

## First Word (simplified)
> Дана строка и нужно найти ее первое слово.

> Это упрощенная версия миссии #first-world.

> Строка состоит только из английских символов и пробелов.
В начале и в конце строки пробелов нет.

> **Входные параметры**: Строка.

> **Выходные параметры**: Строка.

## First Word
>Дана строка и нужно найти ее первое слово.
При решении задачи обратите внимание на следующие моменты:
> * В строке могут встречатся точки и запятые
> * Строка может начинаться с буквы или, к примеру, с пробела или точки
> * В слове может быть апостроф и он является частью слова
> * Весь текст может быть представлен только одним словом и все

> **Входные параметры**: Строка.  
> **Выходные параметры**: Строка.

## Three Words
> Дана строка со словами и числами, разделенными пробелами (один пробел между словами и/или числами). Слова состоят только из букв. Вам нужно проверить есть ли в исходной строке три слова подряд. Для примера, в строке "start 5 one two three 7 end" есть три слова подряд.

> **Входные данные**: Строка со словами (str).

> **Выходные данные**: Ответ как логическое выражение (bool), True или False.

## Bigger Price
> Дана таблица всех доступных продуктов на складе. Данные представлены в виде списка словарей (a list of dicts)

> Ваша миссия тут - это найти ТОП самых дорогих товаров. Количество товаров, которые мы ищем, будет передано в первом аргументе, а сами данные по товарам будут переданы вторым аргументом.

> **Входные данные**: Число и список словарей (int and list of dicts). Каждый словарь имеет 2 ключа "name" и "price".

> **Выходные данные**: Такой же как и второй аргумент.

## Popular Words
> Ваша задача в этой миссии определить популярность определенных слов в тексте.

> На вход вашей функции передается 2 аргумента. Текст и массив слов, популярность которых необходимо определить. При решении этой задачи обратите внимание на следующие моменты
> * Слова необходимо искать во всеx регистрах. Т.е. если необходимо найти слово "one", значит для него будут подходить слова "one", "One", "oNe", "ONE" и.т.д.
> * Искомые слова всегда указаны в нижнем регистре
> * Если слово не найдено ни разу, то его необходимо вернуть в словаре со значением 0 (ноль)

> **Входные параметры**: Текст и массив искомых слов.

> **Выходные параметры**: Словарь, в котором ключами являются искомые слова и значениями то, сколько раз они встречаются в исходном тексте.

## Between Markers (simplified)
> Вам дана строка и два маркера (начальный и конечный). Вам необходимо найти текст, заключенный между двумя этими маркерами. Но есть несколько важных условий.

> Это упрощенная версия миссии [Between Markers](#between-markers).

> * Начальный и конечный маркеры всегда разные.
> * Начальный и конечный маркеры всегда размером в один символ.
> * Начальный и конечный маркеры всегда есть в строке и идут один за другим.

> **Входные данные**: Три аргумента. Все строки. Второй и третий аргументы это начальный и конечный маркеры.

> **Выходные данные**: Строка.

## Between Markers
> Вам дана строка и два маркера (начальный и конечный). Вам необходимо найти текст, заключенный между двумя этими маркерами. Но есть несколько важных условий:

> * Начальный и конечный маркеры всегда разные
> * Если нет начального маркера, то началом считать начало строки
> * Если нет конечного маркера, то концом считать конец строки
> * Если нет ни конечного, ни начального маркеров, то просто вернуть всю строку
> * Если конечный маркер стоит перед начальным, то вернуть пустую строку

> **Входные параметры**: Три аргумента. Все строки. Второй и третий аргументы это начальный и конечный маркеры.

> **Выходные параметры**: Строка.

## Remove All Before
> Не все элементы важны. Вам нужно удалить из список все элементы до указаного.

> На примере мы имеем список [1, 2, 3, 4, 5] где нужно было удалить все элементы до 3 - 1 и 2 соответственно.

> Есть два ньюанса: (1) если в списке нет элемента до которого нужно удалить остальные элементы, то список не должен измениться. (2) если list пустой, то он должен остаться пустым.

> **Входные данные**: Список и элемент до которого нужно удалить другие элементы.

> **Выходные данные**: Набор значений (кортеж, список, итератор ...).
